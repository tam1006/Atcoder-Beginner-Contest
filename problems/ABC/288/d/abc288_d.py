#!/usr/bin/env python3
# from typing import *
import sys
sys.setrecursionlimit(10**7)

from typing import TypeVar, Callable, List
T = TypeVar('T')
# Binaray Indexed Tree
# 1-indexed
class BinaryIndexedTree:
    def __init__(self, data: List[T], identity: T):
        self.data = data
        self.identity = identity
        self.N = len(data) - 1

    # 初期値を配列Aで初期化, 全てidentityの値からの実行
    @classmethod
    def from_list(cls, A: List[T], identity: T):
        data = [identity] * (len(A) + 1)
        self = cls(data, identity)
        for i in range(len(A)):
            self.add(i+1, A[i])
        return self

    @classmethod
    def new(cls, size: int, identity: T):
        data = [identity] * (size + 1)
        return cls(data, identity)

    # i番目の値にxを加算する
    def add(self, i: int, x: T):
        assert 1 <= i <= self.N

        while i <= self.N:
            self.data[i] += x
            i += i & -i

    # [0, i]の和, 1-indexed, i=0なら0を返す
    def sum(self, i) -> T:
        assert 0 <= i <= self.N

        s = self.identity
        while i > 0:
            s += self.data[i]
            i -= i & -i

        return s

    # [l, r)の和, 1-indexed, l=rなら0を返す
    def range_sum(self, l: int, r: int) -> T:
        assert 0 <= l <= r <= self.N+1

        return self.sum(r-1) - self.sum(l-1)

    # i番目の値を取得する
    def get(self, i: int) -> T:
        assert 1 <= i <= self.N

        return self.range_sum(i, i+1)

    # i番目の値をxに更新する
    def update(self, i: int, x: T):
        assert 1 <= i <= self.N

        self.add(i, x - self.get(i))


YES = 'Yes'
NO = 'No'


# def solve(N: int, K: int, A: List[int], Q: int, l: List[int], r: List[int]) -> List[str]:
def solve(N, K, A, Q, l, r):
    BIT = [BinaryIndexedTree.new(N, 0) for _ in range(K)]
    for i in range(N):
        BIT[i%K].add(i+1, A[i])

    # for i in range(Q):
    for ll, rr in zip(l, r):
        tar = BIT[(rr-K+1)%K].range_sum(ll, rr+1)
        flag = True

        for j in range(rr, rr-K-1, -1):
            s = BIT[j%K].range_sum(ll, rr+1)
            if s != tar:
                flag = False
                break

        if flag:
            print(YES)
        else:
            print(NO)




# generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
def main():
    import sys
    tokens = iter(sys.stdin.read().split())
    N = int(next(tokens))
    K = int(next(tokens))
    A = [None for _ in range(N)]
    for i in range(N):
        A[i] = int(next(tokens))
    Q = int(next(tokens))
    l = [None for _ in range(Q)]
    r = [None for _ in range(Q)]
    for i in range(Q):
        l[i] = int(next(tokens))
        r[i] = int(next(tokens))
    assert next(tokens, None) is None
    solve(N, K, A, Q, l, r)


if __name__ == '__main__':
    main()
