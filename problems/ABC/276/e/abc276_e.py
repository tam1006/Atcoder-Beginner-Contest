#!/usr/bin/env python3
# from typing import *
import sys
sys.setrecursionlimit(1000000)

YES = 'Yes'
NO = 'No'

def search(H, W, C):
    for i in range(H):
        for j in range(W):
            if C[i][j] == 'S':
                return i, j

# def solve(H: str, W: str, C: List[List[str]]) -> str:
def solve(H, W, C):
    sx, sy = search(H, W, C)
    
    dx = [1, 0, -1, 0]
    dy = [0, 1, 0, -1]
    for i, coordinate in enumerate(zip(dx, dy)):
        x, y = coordinate
        nx = sx + x
        ny = sy + y
        if 0 <= nx < H and 0 <= ny < W:
            if C[nx][ny] == '.':
                C[nx][ny] = i
            elif C[nx][ny] == '#':
                continue
            elif C[nx][ny] != i:
                return YES
        else:
            continue

        que = [(nx, ny)]
        if bfs(i, que):
            return YES

    return NO

def bfs(i, que):
    global H, W, C
    dx = [1, 0, -1, 0]
    dy = [0, 1, 0, -1]

    while que:
        x, y = que.pop()
        for xx, yy in zip(dx, dy):
            nx = x + xx
            ny = y + yy
            if 0 <= nx < H and 0 <= ny < W:
                if C[nx][ny] == '.':
                    C[nx][ny] = i
                    que.append((nx, ny))
                elif C[nx][ny] == '#':
                    continue
                elif C[nx][ny] != 'S' and C[nx][ny] != i:
                    return True

    return False


# generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
def main():
    import sys
    # tokens = iter(sys.stdin.read().split())
    global H, W, C
    H, W = map(int, input().split())
    C = [list(input()) for _ in range(H)]
    a = solve(H, W, C)
    print(a)


if __name__ == '__main__':
    main()
